// Top-level BNN testbench — plain Icarus Verilog (no cocotb)
// Reads pixels.mem and weights.mem generated by gen_mem_files.py,
// drives tt_um_mnist_bnn serially, and prints the result.
`timescale 1ns/1ps

module tb_top;

// ---------------------------------------------------------------------------
// DUT signals
// ---------------------------------------------------------------------------
reg        clk;
reg        rst_n;
reg  [7:0] ui_in;   // [0]=mode  [1]=pixel_in  [2]=weight_in
reg  [7:0] uio_in;
wire [7:0] uo_out;  // [3:0]=answer digit
wire [7:0] uio_out;
wire [7:0] uio_oe;

// ---------------------------------------------------------------------------
// DUT
// ---------------------------------------------------------------------------
tt_um_mnist_bnn dut (
    .ui_in  (ui_in),
    .uo_out (uo_out),
    .uio_in (uio_in),
    .uio_out(uio_out),
    .uio_oe (uio_oe),
    .ena    (1'b1),
    .clk    (clk),
    .rst_n  (rst_n)
);

// ---------------------------------------------------------------------------
// Clock: 10 ns period
// ---------------------------------------------------------------------------
initial clk = 0;
always  #5 clk = ~clk;

// ---------------------------------------------------------------------------
// Waveform dump (view with gtkwave)
// ---------------------------------------------------------------------------
initial begin
    $dumpfile("top.vcd");
    $dumpvars(0, tb_top);
end

// ---------------------------------------------------------------------------
// Serial stream memory (one bit per address)
// ---------------------------------------------------------------------------
reg pixel_stream  [0:783];    // 784 pixels
reg weight_stream [0:2319];   // 2320 weight bits (w1+w2+w3)

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------
integer i, row, col;

// ---------------------------------------------------------------------------
// Main test
// ---------------------------------------------------------------------------
initial begin
    // Load stream files generated by gen_mem_files.py
    $readmemb("pixels.mem",  pixel_stream);
    $readmemb("weights.mem", weight_stream);

    // Initialise
    ui_in  = 8'b0;
    uio_in = 8'b0;
    rst_n  = 1'b0;

    // -----------------------------------------------------------------------
    // Print input image
    // -----------------------------------------------------------------------
    $display("");
    $display("=== MNIST BNN Top-Level Hardware Test ===");
    $display("Input image (# = white pixel, . = black pixel):");
    $display("+----------------------------+");
    for (row = 0; row < 28; row = row + 1) begin
        $write("|");
        for (col = 0; col < 28; col = col + 1) begin
            if (pixel_stream[row*28 + col] === 1'b1)
                $write("#");
            else
                $write(".");
        end
        $display("|");
    end
    $display("+----------------------------+");
    $display("");

    // -----------------------------------------------------------------------
    // Reset: hold low for 10 cycles
    // -----------------------------------------------------------------------
    repeat(10) @(posedge clk);
    #1 rst_n = 1'b1;
    repeat(2)  @(posedge clk);  // let reset_pipe settle

    // -----------------------------------------------------------------------
    // Assert mode=1 → FSM transitions to s_LOAD on next posedge
    // Registers do NOT capture this cycle (state still s_IDLE at posedge)
    // -----------------------------------------------------------------------
    $display("[%0t] Entering LOAD state...", $time);
    #1 ui_in = 8'b00000001;   // mode=1, no data yet
    @(posedge clk);

    // -----------------------------------------------------------------------
    // Stream 2320 cycles:
    //   Pixels  (bits 0-783)  on cycles 1-784  of s_LOAD
    //   Weights (bits 0-2319) on cycles 1-2320 of s_LOAD
    //     w1 (72 bits)    cycles   1-72
    //     w2 (288 bits)   cycles  73-360
    //     w3 (1960 bits)  cycles 361-2320
    // -----------------------------------------------------------------------
    for (i = 0; i < 2320; i = i + 1) begin
        #1 ui_in = {5'b0,
                    weight_stream[i],
                    (i < 784) ? pixel_stream[i] : 1'b0,
                    1'b1};    // bit2=weight, bit1=pixel, bit0=mode
        @(posedge clk);
    end

    $display("[%0t] LOAD complete. Running inference...", $time);
    #1 ui_in = 8'b0;   // drop mode

    // -----------------------------------------------------------------------
    // Wait for inference layers
    //   s_LAYER_1 : ~1570 cycles  (8 filters × 14×14)
    //   s_LAYER_2 : ~198  cycles  (4 filters × 7×7)
    //   s_LAYER_3 : ~2    cycles  (popcount latch)
    // Wait 2000 cycles for margin.
    // -----------------------------------------------------------------------
    repeat(2000) @(posedge clk);

    // -----------------------------------------------------------------------
    // Read and display result
    // -----------------------------------------------------------------------
    $display("");
    $display("=========================================");
    $display("  Hardware classification: %0d", uo_out[3:0]);
    $display("=========================================");
    $display("");

    $finish;
end

// ---- Timeout watchdog (8000 cycles = well beyond worst case) ---------------
initial begin
    #800000;   // 8000 cycles × 10 ns × 2 (posedge/negedge pairs)
    $display("ERROR: simulation timeout!");
    $finish;
end

endmodule
